REPO := logdna-agent-v2
RUST_REPO := logdna-agent-rust

DOCKER := docker
DOCKER_PRIVATE_IMAGE := us.gcr.io/logdna-k8s/logdna-agent-v2
DOCKER_PUBLIC_IMAGE := docker.io/logdna/logdna-agent
DOCKER_IBM_IMAGE := icr.io/ext/logdna-agent

# The image repo and tag can be modified e.g.
# `make -f Makefile.docker build IMAGE=docker.io/rust:1.42.0`
IMAGE_REPO ?= docker.io/rust
IMAGE_TAG ?= 1.42
IMAGE ?= $(IMAGE_REPO):$(IMAGE_TAG)
IMAGE := $(IMAGE)

VCS_REF := $(shell git rev-parse --short HEAD)
VCS_URL := https://github.com/logdna/logdna-agent-v2
BUILD_TIMESTAMP := $(shell date -u +'%Y-%m-%dT%H:%M:%SZ')
BUILD_VERSION := $(shell sed -nE "s/^version = \"(.+)\"\$$/\1/p" bin/Cargo.toml)
BUILD_TAG := $(VCS_REF)

MAJOR_VERSION := $(shell echo $(BUILD_VERSION) | cut -f1 -d'.')
MINOR_VERSION := $(shell echo $(BUILD_VERSION) | cut -f1-2 -d'.')
PATCH_VERSION := $(shell echo $(BUILD_VERSION) | cut -f1 -d'-')
PRERELEASE_VERSION := $(shell echo $(BUILD_VERSION) | cut -f2 -d'-')

DOCKER_RUN := docker run --rm -w /build -v $(shell pwd):/build:Z $(IMAGE)

# This is to reliably maintain permissions in a cross compatible manner
# (tested on Linux and Mac). The docker container needs the correct
# permissions to build artifcats, but also needs to give ownership of build
# artifacts back to the host machine.
CHOWN := chown -R $(shell id -u):$(shell id -g) .

ifeq ($(ALL), 1)
	CLEAN_ADDTL_FILTERS :=
else
	CLEAN_ADDTL_FILTERS := --filter label=com.logdna.tag=$(BUILD_TAG)
endif

CLEAN_DOCKER_IMAGES = if [[ ! -z "docker images -q $(1)" ]]; then docker images -q $(1) | head -n 1 | xargs -I {} docker rmi -f {}; fi

.PHONY:build
build: ## (Runs in a docker container) Build the agent. Set RELEASE=1 to build a release image - defaults to 0
	$(DOCKER_RUN) /bin/sh -c "make build RELEASE=$(RELEASE) && $(CHOWN)"

.PHONY:test
test: ## (Runs in a docker container) Installs the necessary dependencies and then checks rust syntax, docker syntax, rust warnings, outdated dependencies, security vulnerabilities, and unit tests
	$(DOCKER_RUN) /bin/sh -c "make test && $(CHOWN)"

.PHONY:clean
clean: ## (Runs in a docker container) Clean all artifacts from the build process
	$(DOCKER_RUN) /bin/sh -c "make clean && $(CHOWN)"

.PHONY:clean-images
clean-images: ## Cleans the intermediate and final agent images left over from the build-image target
	@# Clean any intermediate agent images, left over from the multi-stage build
	$(call CLEAN_DOCKER_IMAGES,--filter label=com.logdna.stage=$(REPO)-build $(CLEAN_ADDTL_FILTERS))
	@# Clean any final agent images
	$(call CLEAN_DOCKER_IMAGES,--filter label=com.logdna.stage=$(REPO)-final $(CLEAN_ADDTL_FILTERS))

.PHONY:build-image
build-image: ## Build a docker image as specified in the Dockerfile
	$(DOCKER) build . -t $(REPO):$(BUILD_TAG) \
		--pull --no-cache=true --rm \
		--build-arg BUILD_IMAGE=$(IMAGE) \
		--build-arg BUILD_TIMESTAMP=$(BUILD_TIMESTAMP) \
		--build-arg BUILD_VERSION=$(BUILD_VERSION) \
		--build-arg REPO=$(REPO) \
		--build-arg VCS_REF=$(VCS_REF) \
		--build-arg VCS_URL=$(VCS_URL)
	$(DOCKER) tag $(REPO):$(BUILD_TAG) $(REPO):$(BUILD_VERSION)

.PHONY:publish-private
publish-private: ## Publish a build version of the docker image to our private registry
	for version in $(BUILD_TAG) $(BUILD_VERSION); do \
		$(DOCKER) tag $(REPO):$(BUILD_TAG) $(DOCKER_PRIVATE_IMAGE):$${version}; \
		$(DOCKER) push $(DOCKER_PRIVATE_IMAGE):$${version}; \
	done;

.PHONY:publish-public
publish-public: ## Publish SemVer compliant releases to our public registries
	@# TODO: Have a boolean that prevents this unless forced or run by Jenkins (which can force it)
	for image in $(DOCKER_PUBLIC_IMAGE) $(DOCKER_IBM_IMAGE); do \
		for version in $(MAJOR_VERSION) $(MINOR_VERSION) $(PATCH_VERSION) $(BUILD_VERSION) latest; do \
			if [[ $${version} != $(BUILD_VERSION) ]] && [[ $(PRERELEASE_VERSION) = beta* ]]; then \
				continue; \
			fi; \
			$(DOCKER) tag $(REPO):$(BUILD_TAG) $${image}:$${version}; \
			$(DOCKER) push $${image}:$${version}; \
		done; \
	done;

.PHONY:get-rust-image
get-rust-image:
	@echo $(RUST_REPO):$(BUILD_TAG)

.PHONY:rust-image
rust-image: ## Build a superset of the Rust image that contains necessary dependencies to test the agent
	$(DOCKER) build . -t $(RUST_REPO):$(BUILD_TAG) \
		-f rust-image/Dockerfile \
		--pull --no-cache=true --rm \
		--build-arg BUILD_IMAGE=$(IMAGE) \
		--build-arg REPO=$(RUST_REPO) \
		--build-arg VCS_REF=$(VCS_REF)

.PHONY:publish-rust
publish-rust: ## Publish superset rust image (see target rust-image)
	$(DOCKER) tag $(RUST_REPO):$(BUILD_TAG) docker.pkg.github.com/answerbook/docker-images/$(RUST_REPO):latest
	$(DOCKER) tag $(RUST_REPO):$(BUILD_TAG) us.gcr.io/logdna-k8s/$(RUST_REPO):latest
	$(DOCKER) push docker.pkg.github.com/answerbook/docker-images/$(RUST_REPO):latest
	$(DOCKER) push us.gcr.io/logdna-k8s/$(RUST_REPO):latest

.PHONY:clean-rust-image
clean-rust-image:
	$(call CLEAN_DOCKER_IMAGES,--filter label=com.logdna.stage=$(RUST_REPO)-build $(CLEAN_ADDTL_FILTERS))
	$(call CLEAN_DOCKER_IMAGES,--filter label=com.logdna.stage=$(RUST_REPO)-build $(CLEAN_ADDTL_FILTERS))

.PHONY:help
help: ## Prints out a helpful description of each possible target
	@awk 'BEGIN {FS = ":.*?## "}; /^.+: .*?## / && !/awk/ {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST)
